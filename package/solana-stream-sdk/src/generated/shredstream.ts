// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v3.19.1
// source: shredstream.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "./google/protobuf/timestamp";
import { Socket } from "./shared";

export const protobufPackage = "shredstream";

export enum CommitmentLevel {
  PROCESSED = 0,
  CONFIRMED = 1,
  FINALIZED = 2,
  UNRECOGNIZED = -1,
}

export function commitmentLevelFromJSON(object: any): CommitmentLevel {
  switch (object) {
    case 0:
    case "PROCESSED":
      return CommitmentLevel.PROCESSED;
    case 1:
    case "CONFIRMED":
      return CommitmentLevel.CONFIRMED;
    case 2:
    case "FINALIZED":
      return CommitmentLevel.FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommitmentLevel.UNRECOGNIZED;
  }
}

export function commitmentLevelToJSON(object: CommitmentLevel): string {
  switch (object) {
    case CommitmentLevel.PROCESSED:
      return "PROCESSED";
    case CommitmentLevel.CONFIRMED:
      return "CONFIRMED";
    case CommitmentLevel.FINALIZED:
      return "FINALIZED";
    case CommitmentLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Heartbeat {
  /**
   * don't trust IP:PORT from tcp header since it can be tampered over the wire
   * `socket.ip` must match incoming packet's ip. this prevents spamming an unwitting destination
   */
  socket:
    | Socket
    | undefined;
  /**
   * regions for shredstream proxy to receive shreds from
   * list of valid regions: https://docs.jito.wtf/lowlatencytxnsend/#api
   */
  regions: string[];
}

export interface HeartbeatResponse {
  /** client must respond within `ttl_ms` to keep stream alive */
  ttlMs: number;
}

export interface TraceShred {
  /** source region, one of: https://docs.jito.wtf/lowlatencytxnsend/#api */
  region: string;
  /** timestamp of creation */
  createdAt:
    | Date
    | undefined;
  /** monotonically increases, resets upon service restart */
  seqNum: number;
}

export interface SubscribeEntriesRequest {
  accounts: { [key: string]: SubscribeRequestFilterAccounts };
  transactions: { [key: string]: SubscribeRequestFilterTransactions };
  slots: { [key: string]: SubscribeRequestFilterSlots };
  commitment?: CommitmentLevel | undefined;
}

export interface SubscribeEntriesRequest_AccountsEntry {
  key: string;
  value: SubscribeRequestFilterAccounts | undefined;
}

export interface SubscribeEntriesRequest_TransactionsEntry {
  key: string;
  value: SubscribeRequestFilterTransactions | undefined;
}

export interface SubscribeEntriesRequest_SlotsEntry {
  key: string;
  value: SubscribeRequestFilterSlots | undefined;
}

export interface SubscribeRequestFilterAccounts {
  account: string[];
  owner: string[];
  filters: SubscribeRequestFilterAccountsFilter[];
  nonemptyTxnSignature?: boolean | undefined;
}

export interface SubscribeRequestFilterAccountsFilter {
  memcmp?: SubscribeRequestFilterAccountsFilterMemcmp | undefined;
  datasize?: number | undefined;
  tokenAccountState?: boolean | undefined;
  lamports?: SubscribeRequestFilterAccountsFilterLamports | undefined;
}

export interface SubscribeRequestFilterAccountsFilterMemcmp {
  offset: number;
  bytes?: Uint8Array | undefined;
  base58?: string | undefined;
  base64?: string | undefined;
}

export interface SubscribeRequestFilterAccountsFilterLamports {
  eq?: number | undefined;
  ne?: number | undefined;
  lt?: number | undefined;
  gt?: number | undefined;
}

export interface SubscribeRequestFilterSlots {
  filterByCommitment?: boolean | undefined;
  interslotUpdates?: boolean | undefined;
}

export interface SubscribeRequestFilterTransactions {
  accountInclude: string[];
  accountExclude: string[];
  accountRequired: string[];
}

export interface Entry {
  /** the slot that the entry is from */
  slot: number;
  /** Serialized bytes of Vec<Entry>: https://docs.rs/solana-entry/latest/solana_entry/entry/struct.Entry.html */
  entries: Uint8Array;
}

function createBaseHeartbeat(): Heartbeat {
  return { socket: undefined, regions: [] };
}

export const Heartbeat: MessageFns<Heartbeat> = {
  encode(message: Heartbeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.socket !== undefined) {
      Socket.encode(message.socket, writer.uint32(10).fork()).join();
    }
    for (const v of message.regions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.socket = Socket.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Heartbeat {
    return {
      socket: isSet(object.socket) ? Socket.fromJSON(object.socket) : undefined,
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Heartbeat): unknown {
    const obj: any = {};
    if (message.socket !== undefined) {
      obj.socket = Socket.toJSON(message.socket);
    }
    if (message.regions?.length) {
      obj.regions = message.regions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Heartbeat>, I>>(base?: I): Heartbeat {
    return Heartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Heartbeat>, I>>(object: I): Heartbeat {
    const message = createBaseHeartbeat();
    message.socket = (object.socket !== undefined && object.socket !== null)
      ? Socket.fromPartial(object.socket)
      : undefined;
    message.regions = object.regions?.map((e) => e) || [];
    return message;
  },
};

function createBaseHeartbeatResponse(): HeartbeatResponse {
  return { ttlMs: 0 };
}

export const HeartbeatResponse: MessageFns<HeartbeatResponse> = {
  encode(message: HeartbeatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ttlMs !== 0) {
      writer.uint32(8).uint32(message.ttlMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ttlMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatResponse {
    return { ttlMs: isSet(object.ttlMs) ? globalThis.Number(object.ttlMs) : 0 };
  },

  toJSON(message: HeartbeatResponse): unknown {
    const obj: any = {};
    if (message.ttlMs !== 0) {
      obj.ttlMs = Math.round(message.ttlMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(base?: I): HeartbeatResponse {
    return HeartbeatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(object: I): HeartbeatResponse {
    const message = createBaseHeartbeatResponse();
    message.ttlMs = object.ttlMs ?? 0;
    return message;
  },
};

function createBaseTraceShred(): TraceShred {
  return { region: "", createdAt: undefined, seqNum: 0 };
}

export const TraceShred: MessageFns<TraceShred> = {
  encode(message: TraceShred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== "") {
      writer.uint32(10).string(message.region);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.seqNum !== 0) {
      writer.uint32(24).uint32(message.seqNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceShred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceShred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.seqNum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceShred {
    return {
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      seqNum: isSet(object.seqNum) ? globalThis.Number(object.seqNum) : 0,
    };
  },

  toJSON(message: TraceShred): unknown {
    const obj: any = {};
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.seqNum !== 0) {
      obj.seqNum = Math.round(message.seqNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceShred>, I>>(base?: I): TraceShred {
    return TraceShred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceShred>, I>>(object: I): TraceShred {
    const message = createBaseTraceShred();
    message.region = object.region ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.seqNum = object.seqNum ?? 0;
    return message;
  },
};

function createBaseSubscribeEntriesRequest(): SubscribeEntriesRequest {
  return { accounts: {}, transactions: {}, slots: {}, commitment: undefined };
}

export const SubscribeEntriesRequest: MessageFns<SubscribeEntriesRequest> = {
  encode(message: SubscribeEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.accounts).forEach(([key, value]) => {
      SubscribeEntriesRequest_AccountsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.transactions).forEach(([key, value]) => {
      SubscribeEntriesRequest_TransactionsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.slots).forEach(([key, value]) => {
      SubscribeEntriesRequest_SlotsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.commitment !== undefined) {
      writer.uint32(48).int32(message.commitment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SubscribeEntriesRequest_AccountsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.accounts[entry1.key] = entry1.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SubscribeEntriesRequest_TransactionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.transactions[entry3.key] = entry3.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SubscribeEntriesRequest_SlotsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.slots[entry2.key] = entry2.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.commitment = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeEntriesRequest {
    return {
      accounts: isObject(object.accounts)
        ? Object.entries(object.accounts).reduce<{ [key: string]: SubscribeRequestFilterAccounts }>(
          (acc, [key, value]) => {
            acc[key] = SubscribeRequestFilterAccounts.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      transactions: isObject(object.transactions)
        ? Object.entries(object.transactions).reduce<{ [key: string]: SubscribeRequestFilterTransactions }>(
          (acc, [key, value]) => {
            acc[key] = SubscribeRequestFilterTransactions.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      slots: isObject(object.slots)
        ? Object.entries(object.slots).reduce<{ [key: string]: SubscribeRequestFilterSlots }>((acc, [key, value]) => {
          acc[key] = SubscribeRequestFilterSlots.fromJSON(value);
          return acc;
        }, {})
        : {},
      commitment: isSet(object.commitment) ? commitmentLevelFromJSON(object.commitment) : undefined,
    };
  },

  toJSON(message: SubscribeEntriesRequest): unknown {
    const obj: any = {};
    if (message.accounts) {
      const entries = Object.entries(message.accounts);
      if (entries.length > 0) {
        obj.accounts = {};
        entries.forEach(([k, v]) => {
          obj.accounts[k] = SubscribeRequestFilterAccounts.toJSON(v);
        });
      }
    }
    if (message.transactions) {
      const entries = Object.entries(message.transactions);
      if (entries.length > 0) {
        obj.transactions = {};
        entries.forEach(([k, v]) => {
          obj.transactions[k] = SubscribeRequestFilterTransactions.toJSON(v);
        });
      }
    }
    if (message.slots) {
      const entries = Object.entries(message.slots);
      if (entries.length > 0) {
        obj.slots = {};
        entries.forEach(([k, v]) => {
          obj.slots[k] = SubscribeRequestFilterSlots.toJSON(v);
        });
      }
    }
    if (message.commitment !== undefined) {
      obj.commitment = commitmentLevelToJSON(message.commitment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeEntriesRequest>, I>>(base?: I): SubscribeEntriesRequest {
    return SubscribeEntriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeEntriesRequest>, I>>(object: I): SubscribeEntriesRequest {
    const message = createBaseSubscribeEntriesRequest();
    message.accounts = Object.entries(object.accounts ?? {}).reduce<{ [key: string]: SubscribeRequestFilterAccounts }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SubscribeRequestFilterAccounts.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.transactions = Object.entries(object.transactions ?? {}).reduce<
      { [key: string]: SubscribeRequestFilterTransactions }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SubscribeRequestFilterTransactions.fromPartial(value);
      }
      return acc;
    }, {});
    message.slots = Object.entries(object.slots ?? {}).reduce<{ [key: string]: SubscribeRequestFilterSlots }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SubscribeRequestFilterSlots.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.commitment = object.commitment ?? undefined;
    return message;
  },
};

function createBaseSubscribeEntriesRequest_AccountsEntry(): SubscribeEntriesRequest_AccountsEntry {
  return { key: "", value: undefined };
}

export const SubscribeEntriesRequest_AccountsEntry: MessageFns<SubscribeEntriesRequest_AccountsEntry> = {
  encode(message: SubscribeEntriesRequest_AccountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterAccounts.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeEntriesRequest_AccountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeEntriesRequest_AccountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterAccounts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeEntriesRequest_AccountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterAccounts.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SubscribeEntriesRequest_AccountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterAccounts.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeEntriesRequest_AccountsEntry>, I>>(
    base?: I,
  ): SubscribeEntriesRequest_AccountsEntry {
    return SubscribeEntriesRequest_AccountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeEntriesRequest_AccountsEntry>, I>>(
    object: I,
  ): SubscribeEntriesRequest_AccountsEntry {
    const message = createBaseSubscribeEntriesRequest_AccountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterAccounts.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSubscribeEntriesRequest_TransactionsEntry(): SubscribeEntriesRequest_TransactionsEntry {
  return { key: "", value: undefined };
}

export const SubscribeEntriesRequest_TransactionsEntry: MessageFns<SubscribeEntriesRequest_TransactionsEntry> = {
  encode(message: SubscribeEntriesRequest_TransactionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterTransactions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeEntriesRequest_TransactionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeEntriesRequest_TransactionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterTransactions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeEntriesRequest_TransactionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterTransactions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SubscribeEntriesRequest_TransactionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterTransactions.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeEntriesRequest_TransactionsEntry>, I>>(
    base?: I,
  ): SubscribeEntriesRequest_TransactionsEntry {
    return SubscribeEntriesRequest_TransactionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeEntriesRequest_TransactionsEntry>, I>>(
    object: I,
  ): SubscribeEntriesRequest_TransactionsEntry {
    const message = createBaseSubscribeEntriesRequest_TransactionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterTransactions.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSubscribeEntriesRequest_SlotsEntry(): SubscribeEntriesRequest_SlotsEntry {
  return { key: "", value: undefined };
}

export const SubscribeEntriesRequest_SlotsEntry: MessageFns<SubscribeEntriesRequest_SlotsEntry> = {
  encode(message: SubscribeEntriesRequest_SlotsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterSlots.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeEntriesRequest_SlotsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeEntriesRequest_SlotsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterSlots.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeEntriesRequest_SlotsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterSlots.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SubscribeEntriesRequest_SlotsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterSlots.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeEntriesRequest_SlotsEntry>, I>>(
    base?: I,
  ): SubscribeEntriesRequest_SlotsEntry {
    return SubscribeEntriesRequest_SlotsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeEntriesRequest_SlotsEntry>, I>>(
    object: I,
  ): SubscribeEntriesRequest_SlotsEntry {
    const message = createBaseSubscribeEntriesRequest_SlotsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterSlots.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSubscribeRequestFilterAccounts(): SubscribeRequestFilterAccounts {
  return { account: [], owner: [], filters: [], nonemptyTxnSignature: undefined };
}

export const SubscribeRequestFilterAccounts: MessageFns<SubscribeRequestFilterAccounts> = {
  encode(message: SubscribeRequestFilterAccounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.account) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.owner) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.filters) {
      SubscribeRequestFilterAccountsFilter.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.nonemptyTxnSignature !== undefined) {
      writer.uint32(40).bool(message.nonemptyTxnSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequestFilterAccounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequestFilterAccounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.account.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filters.push(SubscribeRequestFilterAccountsFilter.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.nonemptyTxnSignature = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequestFilterAccounts {
    return {
      account: globalThis.Array.isArray(object?.account) ? object.account.map((e: any) => globalThis.String(e)) : [],
      owner: globalThis.Array.isArray(object?.owner) ? object.owner.map((e: any) => globalThis.String(e)) : [],
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => SubscribeRequestFilterAccountsFilter.fromJSON(e))
        : [],
      nonemptyTxnSignature: isSet(object.nonemptyTxnSignature)
        ? globalThis.Boolean(object.nonemptyTxnSignature)
        : undefined,
    };
  },

  toJSON(message: SubscribeRequestFilterAccounts): unknown {
    const obj: any = {};
    if (message.account?.length) {
      obj.account = message.account;
    }
    if (message.owner?.length) {
      obj.owner = message.owner;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => SubscribeRequestFilterAccountsFilter.toJSON(e));
    }
    if (message.nonemptyTxnSignature !== undefined) {
      obj.nonemptyTxnSignature = message.nonemptyTxnSignature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequestFilterAccounts>, I>>(base?: I): SubscribeRequestFilterAccounts {
    return SubscribeRequestFilterAccounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequestFilterAccounts>, I>>(
    object: I,
  ): SubscribeRequestFilterAccounts {
    const message = createBaseSubscribeRequestFilterAccounts();
    message.account = object.account?.map((e) => e) || [];
    message.owner = object.owner?.map((e) => e) || [];
    message.filters = object.filters?.map((e) => SubscribeRequestFilterAccountsFilter.fromPartial(e)) || [];
    message.nonemptyTxnSignature = object.nonemptyTxnSignature ?? undefined;
    return message;
  },
};

function createBaseSubscribeRequestFilterAccountsFilter(): SubscribeRequestFilterAccountsFilter {
  return { memcmp: undefined, datasize: undefined, tokenAccountState: undefined, lamports: undefined };
}

export const SubscribeRequestFilterAccountsFilter: MessageFns<SubscribeRequestFilterAccountsFilter> = {
  encode(message: SubscribeRequestFilterAccountsFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memcmp !== undefined) {
      SubscribeRequestFilterAccountsFilterMemcmp.encode(message.memcmp, writer.uint32(10).fork()).join();
    }
    if (message.datasize !== undefined) {
      writer.uint32(16).uint64(message.datasize);
    }
    if (message.tokenAccountState !== undefined) {
      writer.uint32(24).bool(message.tokenAccountState);
    }
    if (message.lamports !== undefined) {
      SubscribeRequestFilterAccountsFilterLamports.encode(message.lamports, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequestFilterAccountsFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequestFilterAccountsFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memcmp = SubscribeRequestFilterAccountsFilterMemcmp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.datasize = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tokenAccountState = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lamports = SubscribeRequestFilterAccountsFilterLamports.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequestFilterAccountsFilter {
    return {
      memcmp: isSet(object.memcmp) ? SubscribeRequestFilterAccountsFilterMemcmp.fromJSON(object.memcmp) : undefined,
      datasize: isSet(object.datasize) ? globalThis.Number(object.datasize) : undefined,
      tokenAccountState: isSet(object.tokenAccountState) ? globalThis.Boolean(object.tokenAccountState) : undefined,
      lamports: isSet(object.lamports)
        ? SubscribeRequestFilterAccountsFilterLamports.fromJSON(object.lamports)
        : undefined,
    };
  },

  toJSON(message: SubscribeRequestFilterAccountsFilter): unknown {
    const obj: any = {};
    if (message.memcmp !== undefined) {
      obj.memcmp = SubscribeRequestFilterAccountsFilterMemcmp.toJSON(message.memcmp);
    }
    if (message.datasize !== undefined) {
      obj.datasize = Math.round(message.datasize);
    }
    if (message.tokenAccountState !== undefined) {
      obj.tokenAccountState = message.tokenAccountState;
    }
    if (message.lamports !== undefined) {
      obj.lamports = SubscribeRequestFilterAccountsFilterLamports.toJSON(message.lamports);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequestFilterAccountsFilter>, I>>(
    base?: I,
  ): SubscribeRequestFilterAccountsFilter {
    return SubscribeRequestFilterAccountsFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequestFilterAccountsFilter>, I>>(
    object: I,
  ): SubscribeRequestFilterAccountsFilter {
    const message = createBaseSubscribeRequestFilterAccountsFilter();
    message.memcmp = (object.memcmp !== undefined && object.memcmp !== null)
      ? SubscribeRequestFilterAccountsFilterMemcmp.fromPartial(object.memcmp)
      : undefined;
    message.datasize = object.datasize ?? undefined;
    message.tokenAccountState = object.tokenAccountState ?? undefined;
    message.lamports = (object.lamports !== undefined && object.lamports !== null)
      ? SubscribeRequestFilterAccountsFilterLamports.fromPartial(object.lamports)
      : undefined;
    return message;
  },
};

function createBaseSubscribeRequestFilterAccountsFilterMemcmp(): SubscribeRequestFilterAccountsFilterMemcmp {
  return { offset: 0, bytes: undefined, base58: undefined, base64: undefined };
}

export const SubscribeRequestFilterAccountsFilterMemcmp: MessageFns<SubscribeRequestFilterAccountsFilterMemcmp> = {
  encode(message: SubscribeRequestFilterAccountsFilterMemcmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).uint64(message.offset);
    }
    if (message.bytes !== undefined) {
      writer.uint32(18).bytes(message.bytes);
    }
    if (message.base58 !== undefined) {
      writer.uint32(26).string(message.base58);
    }
    if (message.base64 !== undefined) {
      writer.uint32(34).string(message.base64);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequestFilterAccountsFilterMemcmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequestFilterAccountsFilterMemcmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base58 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.base64 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequestFilterAccountsFilterMemcmp {
    return {
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : undefined,
      base58: isSet(object.base58) ? globalThis.String(object.base58) : undefined,
      base64: isSet(object.base64) ? globalThis.String(object.base64) : undefined,
    };
  },

  toJSON(message: SubscribeRequestFilterAccountsFilterMemcmp): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.bytes !== undefined) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    if (message.base58 !== undefined) {
      obj.base58 = message.base58;
    }
    if (message.base64 !== undefined) {
      obj.base64 = message.base64;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequestFilterAccountsFilterMemcmp>, I>>(
    base?: I,
  ): SubscribeRequestFilterAccountsFilterMemcmp {
    return SubscribeRequestFilterAccountsFilterMemcmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequestFilterAccountsFilterMemcmp>, I>>(
    object: I,
  ): SubscribeRequestFilterAccountsFilterMemcmp {
    const message = createBaseSubscribeRequestFilterAccountsFilterMemcmp();
    message.offset = object.offset ?? 0;
    message.bytes = object.bytes ?? undefined;
    message.base58 = object.base58 ?? undefined;
    message.base64 = object.base64 ?? undefined;
    return message;
  },
};

function createBaseSubscribeRequestFilterAccountsFilterLamports(): SubscribeRequestFilterAccountsFilterLamports {
  return { eq: undefined, ne: undefined, lt: undefined, gt: undefined };
}

export const SubscribeRequestFilterAccountsFilterLamports: MessageFns<SubscribeRequestFilterAccountsFilterLamports> = {
  encode(
    message: SubscribeRequestFilterAccountsFilterLamports,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.eq !== undefined) {
      writer.uint32(8).uint64(message.eq);
    }
    if (message.ne !== undefined) {
      writer.uint32(16).uint64(message.ne);
    }
    if (message.lt !== undefined) {
      writer.uint32(24).uint64(message.lt);
    }
    if (message.gt !== undefined) {
      writer.uint32(32).uint64(message.gt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequestFilterAccountsFilterLamports {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequestFilterAccountsFilterLamports();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eq = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ne = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lt = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequestFilterAccountsFilterLamports {
    return {
      eq: isSet(object.eq) ? globalThis.Number(object.eq) : undefined,
      ne: isSet(object.ne) ? globalThis.Number(object.ne) : undefined,
      lt: isSet(object.lt) ? globalThis.Number(object.lt) : undefined,
      gt: isSet(object.gt) ? globalThis.Number(object.gt) : undefined,
    };
  },

  toJSON(message: SubscribeRequestFilterAccountsFilterLamports): unknown {
    const obj: any = {};
    if (message.eq !== undefined) {
      obj.eq = Math.round(message.eq);
    }
    if (message.ne !== undefined) {
      obj.ne = Math.round(message.ne);
    }
    if (message.lt !== undefined) {
      obj.lt = Math.round(message.lt);
    }
    if (message.gt !== undefined) {
      obj.gt = Math.round(message.gt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequestFilterAccountsFilterLamports>, I>>(
    base?: I,
  ): SubscribeRequestFilterAccountsFilterLamports {
    return SubscribeRequestFilterAccountsFilterLamports.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequestFilterAccountsFilterLamports>, I>>(
    object: I,
  ): SubscribeRequestFilterAccountsFilterLamports {
    const message = createBaseSubscribeRequestFilterAccountsFilterLamports();
    message.eq = object.eq ?? undefined;
    message.ne = object.ne ?? undefined;
    message.lt = object.lt ?? undefined;
    message.gt = object.gt ?? undefined;
    return message;
  },
};

function createBaseSubscribeRequestFilterSlots(): SubscribeRequestFilterSlots {
  return { filterByCommitment: undefined, interslotUpdates: undefined };
}

export const SubscribeRequestFilterSlots: MessageFns<SubscribeRequestFilterSlots> = {
  encode(message: SubscribeRequestFilterSlots, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filterByCommitment !== undefined) {
      writer.uint32(8).bool(message.filterByCommitment);
    }
    if (message.interslotUpdates !== undefined) {
      writer.uint32(16).bool(message.interslotUpdates);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequestFilterSlots {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequestFilterSlots();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.filterByCommitment = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.interslotUpdates = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequestFilterSlots {
    return {
      filterByCommitment: isSet(object.filterByCommitment) ? globalThis.Boolean(object.filterByCommitment) : undefined,
      interslotUpdates: isSet(object.interslotUpdates) ? globalThis.Boolean(object.interslotUpdates) : undefined,
    };
  },

  toJSON(message: SubscribeRequestFilterSlots): unknown {
    const obj: any = {};
    if (message.filterByCommitment !== undefined) {
      obj.filterByCommitment = message.filterByCommitment;
    }
    if (message.interslotUpdates !== undefined) {
      obj.interslotUpdates = message.interslotUpdates;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequestFilterSlots>, I>>(base?: I): SubscribeRequestFilterSlots {
    return SubscribeRequestFilterSlots.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequestFilterSlots>, I>>(object: I): SubscribeRequestFilterSlots {
    const message = createBaseSubscribeRequestFilterSlots();
    message.filterByCommitment = object.filterByCommitment ?? undefined;
    message.interslotUpdates = object.interslotUpdates ?? undefined;
    return message;
  },
};

function createBaseSubscribeRequestFilterTransactions(): SubscribeRequestFilterTransactions {
  return { accountInclude: [], accountExclude: [], accountRequired: [] };
}

export const SubscribeRequestFilterTransactions: MessageFns<SubscribeRequestFilterTransactions> = {
  encode(message: SubscribeRequestFilterTransactions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accountInclude) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.accountExclude) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.accountRequired) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequestFilterTransactions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequestFilterTransactions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountInclude.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountExclude.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accountRequired.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequestFilterTransactions {
    return {
      accountInclude: globalThis.Array.isArray(object?.accountInclude)
        ? object.accountInclude.map((e: any) => globalThis.String(e))
        : [],
      accountExclude: globalThis.Array.isArray(object?.accountExclude)
        ? object.accountExclude.map((e: any) => globalThis.String(e))
        : [],
      accountRequired: globalThis.Array.isArray(object?.accountRequired)
        ? object.accountRequired.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubscribeRequestFilterTransactions): unknown {
    const obj: any = {};
    if (message.accountInclude?.length) {
      obj.accountInclude = message.accountInclude;
    }
    if (message.accountExclude?.length) {
      obj.accountExclude = message.accountExclude;
    }
    if (message.accountRequired?.length) {
      obj.accountRequired = message.accountRequired;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequestFilterTransactions>, I>>(
    base?: I,
  ): SubscribeRequestFilterTransactions {
    return SubscribeRequestFilterTransactions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequestFilterTransactions>, I>>(
    object: I,
  ): SubscribeRequestFilterTransactions {
    const message = createBaseSubscribeRequestFilterTransactions();
    message.accountInclude = object.accountInclude?.map((e) => e) || [];
    message.accountExclude = object.accountExclude?.map((e) => e) || [];
    message.accountRequired = object.accountRequired?.map((e) => e) || [];
    return message;
  },
};

function createBaseEntry(): Entry {
  return { slot: 0, entries: new Uint8Array(0) };
}

export const Entry: MessageFns<Entry> = {
  encode(message: Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slot !== 0) {
      writer.uint32(8).uint64(message.slot);
    }
    if (message.entries.length !== 0) {
      writer.uint32(18).bytes(message.entries);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entries = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entry {
    return {
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      entries: isSet(object.entries) ? bytesFromBase64(object.entries) : new Uint8Array(0),
    };
  },

  toJSON(message: Entry): unknown {
    const obj: any = {};
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.entries.length !== 0) {
      obj.entries = base64FromBytes(message.entries);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Entry>, I>>(base?: I): Entry {
    return Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Entry>, I>>(object: I): Entry {
    const message = createBaseEntry();
    message.slot = object.slot ?? 0;
    message.entries = object.entries ?? new Uint8Array(0);
    return message;
  },
};

export type ShredstreamService = typeof ShredstreamService;
export const ShredstreamService = {
  /** RPC endpoint to send heartbeats to keep shreds flowing */
  sendHeartbeat: {
    path: "/shredstream.Shredstream/SendHeartbeat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Heartbeat) => Buffer.from(Heartbeat.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Heartbeat.decode(value),
    responseSerialize: (value: HeartbeatResponse) => Buffer.from(HeartbeatResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HeartbeatResponse.decode(value),
  },
} as const;

export interface ShredstreamServer extends UntypedServiceImplementation {
  /** RPC endpoint to send heartbeats to keep shreds flowing */
  sendHeartbeat: handleUnaryCall<Heartbeat, HeartbeatResponse>;
}

export interface ShredstreamClient extends Client {
  /** RPC endpoint to send heartbeats to keep shreds flowing */
  sendHeartbeat(
    request: Heartbeat,
    callback: (error: ServiceError | null, response: HeartbeatResponse) => void,
  ): ClientUnaryCall;
  sendHeartbeat(
    request: Heartbeat,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HeartbeatResponse) => void,
  ): ClientUnaryCall;
  sendHeartbeat(
    request: Heartbeat,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HeartbeatResponse) => void,
  ): ClientUnaryCall;
}

export const ShredstreamClient = makeGenericClientConstructor(
  ShredstreamService,
  "shredstream.Shredstream",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ShredstreamClient;
  service: typeof ShredstreamService;
  serviceName: string;
};

export type ShredstreamProxyService = typeof ShredstreamProxyService;
export const ShredstreamProxyService = {
  subscribeEntries: {
    path: "/shredstream.ShredstreamProxy/SubscribeEntries",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeEntriesRequest) => Buffer.from(SubscribeEntriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubscribeEntriesRequest.decode(value),
    responseSerialize: (value: Entry) => Buffer.from(Entry.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Entry.decode(value),
  },
} as const;

export interface ShredstreamProxyServer extends UntypedServiceImplementation {
  subscribeEntries: handleServerStreamingCall<SubscribeEntriesRequest, Entry>;
}

export interface ShredstreamProxyClient extends Client {
  subscribeEntries(request: SubscribeEntriesRequest, options?: Partial<CallOptions>): ClientReadableStream<Entry>;
  subscribeEntries(
    request: SubscribeEntriesRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Entry>;
}

export const ShredstreamProxyClient = makeGenericClientConstructor(
  ShredstreamProxyService,
  "shredstream.ShredstreamProxy",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ShredstreamProxyClient;
  service: typeof ShredstreamProxyService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
